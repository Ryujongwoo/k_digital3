GET _cat/indices?v
# 인덱스 매핑 보기
GET kibana_sample_data_ecommerce/_mapping
# 인덱스에 저장된 전체 도큐먼트 보기
GET kibana_sample_data_ecommerce/_search

# 엘라스틱서치 검색

# 엘라스틱서치 검색 엔진을 사용하려면 쿼리 사용법을 알아야 한다.
# "_search"는 검색 쿼리를 위해서 엘라스틱 서치에서 제공하는 REST API 이다.
# 텍스트, 숫자, 정형, 비정형 데이터를 저장한 다음에 인덱싱을 마치고 나면 쿼리를 실행해서 결과를 얻어올 수 있다.

# 쿼리 컨텍스트(query context)
# 쿼리 컨텍스트는 질의에 대한 유사도를 계산해 이를 기준으로 더 정확한 결과를 먼저 보여준다.
# 검색할 내용이 "엘라스틱"일 때 도큐먼트에 "엘라스틱"이 포함되어 있는지 검색할 때 사용한다.

# GET 인덱스 이름/_search
# {
#   "query": {
#     "실행할 쿼리 이름": {
#       "필드 이름": "검색어"
#     }
#   }
# }

# 쿼리를 사용(조건을 설정)해서 도큐먼트 보기
# "match"는 전문 검색을 위한 쿼리로, 역인덱싱된 용어를 검색할 때 사용한다.
# "kibana_sample_data_ecommerce" 인덱스에서 "category" 필드의 역인덱스 테이블에 "clothing"라는 용어가 있는 모든 도큐먼트를 찾는다.
# select * from kibana_sample_data_ecommerce where category like '%clothing%'
GET kibana_sample_data_ecommerce/_search
{
  "query": {
    "match": {
      "category": "clothing"
    }
  }
}

# 필터 컨텍스트(filter context)
# 필터 컨텍스트는 질의에 대한 유사도를 계산하지 않고 일치 여부에 따른 결과만 보여준다.
# 검색할 내용이 "엘라스틱"일 때 도큐먼트에 정확히 "엘라스틱"인지 검색할 때 사용한다.

# GET 인덱스 이름/_search
# {
#   "query": {
#     "실행할 쿼리 이름": {
#       "filter": [
#         {
#           "필터에 사용할 쿼리 이름": {
#             "필드 이름": "검색어"
#           }
#         }
#       ]
#     }
#   }
# }

# 필터를 사용(조건을 설정)해서 도큐먼트 보기
# "bool"은 논리 쿼리로 내부 "filter"의 타입에 적용된다.
# "kibana_sample_data_ecommerce" 인덱스에서 "day_of_week" 필드에 저장된 값이 정확히 "Friday"인 모든 도큐먼트를 찾는다.
# select * from kibana_sample_data_ecommerce where day_of_week = 'Friday'
GET kibana_sample_data_ecommerce/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "day_of_week": "Friday"
          }
        }
      ]
    }
  }
}

# ===========================================================================================

# 쿼리 스트링(query string)과 쿼리 DSL(query Domain Specific Language)
# 엘라스틱서치에서 쿼리를 사용하는 방법은 쿼리 스트링과 쿼리 DSL 두 가지가 있다.
# 쿼리 스트링은 한 줄 절도의 간단한 쿼리에 사용하고 쿼리 DSL은 한 줄에 넣기 힘든 복잡한 쿼리에 사용된다.
# 쿼리 DSL은 엘라스틱서치에서 제공하는 쿼리 전용 언어로 json 기반의 언어이다.

# 쿼리 스트링
# 쿼리 스트링은 REST API의 URL에 쿼리문을 작성하는 방식으로 실행할 수 있어서 사용하기 쉽다.
# 복잡한 논리 조건의 경우 괄호를 이용해야 하는데, 조건이 복잡해지면 가독성이 좋지 않고 오류를 범하기 쉽다. => 간단한 쿼리에 사용한다.

GET kibana_sample_data_ecommerce/_search?q=customer_full_name:Mary

# 쿼리 DSL
# 쿼리 DSL은 REST API의 요청 본문({} 블록) 내부에 json 형태로 쿼리를 작성한다.
# 엘라스틱서치의 모든 쿼리를 지원하기 때문에 매우 강력하며 복잡한 쿼리를 구현할 수 있는 장점이 있다. => 복잡한 쿼리에 사용한다.

GET kibana_sample_data_ecommerce/_search
{
  "query": {
    "match": {
      "customer_full_name": "Mary"
    }
  }
}

# ===========================================================================================

# 유사도 스코어
# 쿼리 컨텍스트에서는 엘라스틱서치가 지원하는 다양한 유사도 스코어 알고리즘을 사용할 수 있는데 기본적으로 BM25 알고리즘을 이용해 유사도 스코어를 계산한다.
# 유사도 스코어는 질의문과 토큐먼트의 유사도를 표현하는 값으로, 유사도 스코어가 높을수록 찾고자 하는 도큐먼트에 가깝다는 사실을 의미한다.
# "explain": true를 추가하면 쿼리 내부적인 최적화 방법과 어떤 경로를 통해 검색되었으며 어떤 기준으로 유사도 스코어가 계산되었는지 알 수 있다.

GET kibana_sample_data_ecommerce/_search
{
  "query": {
    "match": {
      "products.product_name": "Pants"
    }
  },
  "explain": true
}

# ===========================================================================================

# 쿼리
# 엘라스틱서치는 검색을 위해 쿼리를 지원하고 크게 리프 쿼리와 복합 쿼리로 나눌 수 있다.
# 리프 쿼리(leaf query): 특정 필드에서 용어를 찾는 쿼리로 match, term, range 등이 있다.
# 복합 쿼리(compound query): 쿼리를 조합해서 사용하는 쿼리로 bool 등이 있다.

# 전문 쿼리는 전문 검색을 하기 위해 사용되며, 전문 검색을 할 필드는 인덱스 매핑시 text 타입으로 매핑해야 한다.
# 전문 쿼리는 일반적으로 블로그처럼 텍스트가 많은 필드에서 특정 용어를 검색할 때 사용되며 구글이나 네이버에서 검색어를 이용해 검색사는 방식이 전문 쿼리와 같다고 생각하면 된다.

# 용어 수준 쿼리는 정확히 일치하는 용어를 찾기 위해 사용되며, 용어 수준 검색을 할 필드는 인덱스 매핑시 keyword 타입으로 매핑해야 한다.
# 용어 수준 쿼리는 전문 쿼리와 달리 정확한 용어를 검색할 때 사용되며, 일반적으로 숫자, 날짜 범주셩 데이터를 정확히 검색할 때 사용된다.

# match query => 단어 전문 검색
# match query는 전문 쿼리의 가장 기본이 되는 쿼리로, 전체 텍스트 중에서 특정 용어나 용어들을 검색할 때 사용한다.
# match query를 사용하기 위해서는 검색하고 싶은 필드를 알아야 한다. 필드명을 모르면 쿼리를 진행할 수 없으므로 "GET kibana_sample_data_ecommerce/_mapping"를 실행해서 인덱스에 포함된 필드가 어떤 것들이 있는지 확인해야 한다.

# 한 개의 용어를 전문 검색하는 match query
# "_source" 파라미터는 생략시 인덱스의 전체 필드를 얻어오고 인덱스에 매핑된 필드 중에서 특정 필드면 보고 싶다면 [] 안에 보고 싶은 필드를 지정하면 되고 보고 싶은 필드가 2개 이상이면 ","로 구분해서 필드를 나열한다.  
# select customer_full_name, customer_first_name, customer_last_name from kibana_sample_data_ecommerce where customer_full_name like '%Mary%'
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name", "customer_first_name", "customer_last_name"], 
  "query": {
    "match": {
      "customer_full_name": "Mary"
    }
  }
}

# 여러 개의 용어를 전문 검색하는 match query
# 검색할 필드에 "Mary Pope"와 같이 검색어를 띄어쓰기를 경계로 나열하면 "or" 연산으로 인식한다.
# select customer_full_name, customer_gender from kibana_sample_data_ecommerce where customer_full_name like '%Mary%' or customer_full_name like '%Pope%'
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name", "customer_gender"], 
  "query": {
    "match": {
      "customer_full_name": "Mary Pope"
    }
  }
}

# "and" 연산을 사용하려면 아래와 같이 검색할 필드에 {}를 이용해서 "query" 파라미터로 검색어를 지정하고 "operator" 파라미터로 "and" 연산을 명시적으로 지정하면 된다.
# "operator" 파라미터는 생략시 "or"가 기본값으로 사용된다.
# select customer_full_name, customer_gender from kibana_sample_data_ecommerce where customer_full_name like '%Mary%' and customer_full_name like '%Pope%'
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name", "customer_gender"], 
  "query": {
    "match": {
      "customer_full_name": {
        "query": "Mary Pope",
        "operator": "and"
      }
    }
  }
}

# ===========================================================================================

# match_phrase query => 문장 전문 검색
# match query는 단어를 가지고 전문 검색을 실행하지만 match_phrase query는 "빨강색 바지", "85인치 텔레비전"같이 2개 이상의 단어가 연결되어 만들어지는 문장(phrase, 구절)을 가지고 전문 검색을 실행한다.
# "빨강색 바지"를 검색 한다는 것은 "바지 빨강색"을 찾으려는 의도가 아니므로 문장을 구성하는 단어의 순서가 중요하다.
# match_phrase query는 검색시 많은 자원을 요구하기 때문에 자주 사용하지 것은 좋지 않다.

# "customer_full_name" 필드에 "Mary Bailey" 순서로 입력된 데이터가 있으므로 검색된다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"], 
  "query": {
    "match_phrase": {
      "customer_full_name": "Mary Bailey"
    }
  }
}

# "customer_full_name" 필드에 "Bailey Mary" 순서로 입력된 데이터가 없으므로 검색되지 않는다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"], 
  "query": {
    "match_phrase": {
      "customer_full_name": "Bailey Mary"
    }
  }
}

# ===========================================================================================

# term query
# term(용어) query는 용어 수준 쿼리의 대표적인 쿼리로 형식은 match query와 비슷하지만 match query는 분석기에 의새 검색어가 토큰화되고 대소문자를 구분하지 않지만 term query는 분석기에 의해 검색어가 토큰화되지 않고 대소문자도 구분하는 차이점이 있다.

# GET 인덱스 이름/_search
# {
#   "query": {
#     "term": {
#       "용어 검색할 필드 이름": {
#         "value": "검색할 용어"
#       }
#     }
#   }
# }

# "용어 검색할 필드 이름"의 {} 블록에 "value" 파라미터 1개만 필요하므로 {} 블록과 "value" 파라미터를 생략해도 정상적으로 실행된다.
# GET 인덱스 이름/_search
# {
#   "query": {
#     "term": {
#       "용어 검색할 필드 이름": "검색할 용어"
#     }
#   }
# }

# text 타입의 필드에 대한 term query
# "customer_full_name" 필드는 text 타입의 필드이므로 term query를 실행하면 아무것도 검색되지 않는다.
# text 타입으로 선언된 필드는 term query는 실행할 수 없고 match query나 match_phrase query를 실행해야 한다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"],
  "query": {
    "term": {
      "customer_full_name": {
        "value": "Mary Bailey"
      }
    }
  }
}

# keyword 타입의 필드에 대한 term query
# "customer_full_name" 필드는 text 타입을 지정해서 전문 검색이 가능하게 선언했고 "fields" 파라미터를 이용해서 "keyword" 필드를 별도로 만들고 용어 검색이 가능하게 keyword 타입을 지정했다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"],
  "query": {
    "term": {
      "customer_full_name.keyword": {
        "value": "Mary Bailey"
      }
    }
  }
}

# 아래와 같이 term query를 만들어도 정상적으로 실행된다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"],
  "query": {
    "term": {
      "customer_full_name.keyword": "Mary Bailey"
    }
  }
}

# term query는 대문자와 소문자를 구분하기 때문에 검색어를 위와 같이 "Mary Bailey"로 지정하면 검색되지만 아래와 같이 "mary mailey"로 지정하면 검색되지 않는다.
GET kibana_sample_data_ecommerce/_search
{
  "_source": ["customer_full_name"],
  "query": {
    "term": {
      "customer_full_name.keyword": {
        "value": "mary mailey"
      }
    }
  }
}