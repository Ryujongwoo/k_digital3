input {
  file {
    path => "C:/k_digital/kdigital/elasticStack/logstash-7.17.21/config/filter-example.log"
    start_position => "beginning"
    sincedb_path => "nul"
  }
}

filter {
  # grok 플러그인
  grok {
    match => {
      # grok 플러그인은 match을 이용해서 message 필드에 저장된 값을 분리(파싱)해서 필드로 저장한다.
      # grok 플러그인은 자주 사용하는 정규식을 패턴화해뒀으며 이를 이용해 "%{패턴:필드명}" 형태로 데이터를 특정 필드로 파싱할 수 있다.
      # grok 플러그인은 자주 사용하는 패턴화된 정규식은 아래 주소를 참조한다.
      # https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/ecs-v1/grok-patterns
      # NUMBER: 십신수를 인식하는 패턴
      # SPACE: 하나 이상의 공백을 인식하는 패턴
      # URI: 웹 주소를 인식하는 패턴
      # IP: IP 주소를 인식하는 패턴
      # LOGLEVEL: 로그 레벨을 인식하는 패턴
      # TIMESTAMP_ISO8601: ISO8601 표준의 날짜(2024-06-19T12:23:27+09:00 형태)를 인식하는 패턴
      # DATA: 데이터를 인식하는 패턴, 직전 패턴부터 다음 패턴 사이를 모두 인식한다.
      # GREEDYDATA: DATA 패턴과 동일하나 정규식 패턴의 마지막에 사용하면 끝까지 모두 데이터로 인식하는 패턴
      # 자주 사용하는 패턴은 이미 만들어져 있기 때문에 가져다 사용하면 되고, 원하는 패턴이 없는 경우 패턴을 직접 만들어 사용한다.

      # "[", "]", "-", "." 같이 구분자로 사용되는(저장할 필요 없는) 기호는 역슬래시(\)를 붙여서 사용한다.
      # \[%{TIMESTAMP_ISO8601:timestamp}\] => 1번째 대괄호 사이의 문자열을 읽어서 timestamp 필드를 만들어 저장한다.
      # "\[%{TIMESTAMP_ISO8601:timestamp}\] \[%{DATA:id}\]"와 같이 패턴을 지정하면 1번째 대괄호와 2번째 대괄호 사이에 
      # 공백이 1칸인 로그와 3칸인 로그가 존재하기 때문에 "_grokparsefailure" 에러가 발생된다.
      # [2024-06-18 11:47:51] [ID1] 192.168.0.35 9500 [INFO] - connected.
      # [2024-06-18 11:49:05]   [ID2] 218.35.25.165 1004 [warn] - busy server
      # 이런 문제를 해결하려면 연속해서 나타나는 공백을 "[ ]*"를 사용해서 무시하면 된다.
      # \[%{DATA:id}\] => 2번째 대괄호 사이의 문자열을 읽어서 id 필드를 만들어 저장한다.
      # %{IP:ip} => id 다음의 공백 1칸 다음의 문자열을 읽어서 ip 필드를 만들어 저장한다.
      # %{NUMBER:port} => ip 다음의 공백 1칸 다음의 문자열을 읽어서 port 필드를 만들어 저장한다.
      # \[%{LOGLEVEL:level}\] => 3번째 대괄호 사이의 문자열을 읽어서 level 필드를 만들어 저장한다.
      # %{GREEDYDATA:msg} => level 다음의 " - " 건너뛰고 끝까지 읽어서 msg 필드를 만들어 저장한다.
      # %{GREEDYDATA:msg}를 사용하지 않고 %{DATA:msg}를 사용하면 "."에 대한 패턴 정의가 없기 때문에 읽어들이지 못해서 msg 필드가
      # 생성되지 않고 "."에 대한 패턴 정의를 위해서 %{DATA:msg} 뒤에 "\."를 붙이면 "."이 없는 데이터는 에러가 발생된다.
      # %{NUMBER:port}의 결과를 엘라스틱서치에 저장하면 문자열 타입으로 매핑된다. 문자열이 아니라 정수 타입으로 엘라스틱서치가 인식하게
      # 하려면 %{NUMBER:port:int}와 같이 ":int"를 추가하면 된다.
      "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] [ ]*\[%{DATA:id}\] %{IP:ip} %{NUMBER:port:int} \[%{LOGLEVEL:level}\] \- %{GREEDYDATA:msg}"
    }
  }
}

output {
  stdout { }
}